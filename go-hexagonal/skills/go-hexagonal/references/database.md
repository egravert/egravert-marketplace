# Database Patterns

SQLite database layer using sqlc for type-safe queries and goose for migrations. The storage layer wraps generated code and translates between database types and domain types.

## Table of Contents

- [sqlc Configuration](#sqlc-configuration)
- [Writing Queries](#writing-queries)
- [Goose Migrations](#goose-migrations)
- [Repository Implementation](#repository-implementation)
- [Type Translation](#type-translation)
- [SQL Conventions](#sql-conventions)

---

## sqlc Configuration

```yaml
# sqlc.yml
version: "2"
sql:
  - engine: "sqlite"
    queries: "db/queries/"
    schema: "db/migrations/"
    gen:
      go:
        package: "db"
        out: "internal/storage/db"
```

- Schema source is the migrations directory — sqlc reads goose migrations to understand the schema
- Generated code goes into `internal/storage/db/` — never edit these files
- Run `sqlc generate` after changing queries or migrations

---

## Writing Queries

Place SQL files in `db/queries/`, organized by entity.

### Annotations

```sql
-- name: GetBoardgameByID :one
SELECT * FROM boardgame WHERE id = ?;

-- name: ListBoardgames :many
SELECT * FROM boardgame ORDER BY name;

-- name: CreateBoardgame :one
INSERT INTO boardgame (name, min_players, max_players, complexity, description)
VALUES (?, ?, ?, ?, ?)
RETURNING *;

-- name: UpdateBoardgame :exec
UPDATE boardgame SET name = ?, complexity = ? WHERE id = ?;

-- name: DeleteBoardgame :exec
DELETE FROM boardgame WHERE id = ?;

-- name: SearchBoardgames :many
SELECT * FROM boardgame WHERE name LIKE '%' || ? || '%';
```

### Return Modes

| Annotation | Use Case |
|-----------|----------|
| `:one` | Single row (SELECT by ID, INSERT RETURNING) |
| `:many` | Multiple rows (LIST, SEARCH) |
| `:exec` | No return value (UPDATE, DELETE) |
| `:execresult` | Returns `sql.Result` (affected rows) |

### Generated Output

sqlc generates:
- `models.go` — struct types matching database tables
- `<entity>.sql.go` — type-safe query methods on `*Queries`
- Parameter structs for multi-column inserts/updates

```go
// Generated by sqlc — do not edit
type Boardgame struct {
    ID         int64
    Name       string
    MinPlayers sql.NullInt64
    MaxPlayers sql.NullInt64
    Complexity sql.NullInt64
}

type CreateBoardgameParams struct {
    Name       string
    MinPlayers sql.NullInt64
    MaxPlayers sql.NullInt64
    Complexity sql.NullInt64
}

func (q *Queries) CreateBoardgame(ctx context.Context, arg CreateBoardgameParams) (Boardgame, error) { ... }
```

---

## Goose Migrations

Place migrations in `db/migrations/`.

### Creating Migrations

```bash
goose -dir db/migrations create add_boardgame sql
```

### Migration Format

```sql
-- +goose Up
-- +goose StatementBegin
CREATE TABLE boardgame (
    id               INTEGER PRIMARY KEY,
    name             TEXT NOT NULL,
    min_players      INTEGER,
    max_players      INTEGER,
    complexity       INTEGER,
    description      TEXT NOT NULL DEFAULT '',
    CHECK ((min_players IS NULL AND max_players IS NULL) OR
           (min_players IS NOT NULL AND max_players IS NOT NULL AND max_players >= min_players)),
    CHECK (complexity IS NULL OR (complexity >= 1 AND complexity <= 5))
) STRICT;
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
DROP TABLE IF EXISTS boardgame;
-- +goose StatementEnd
```

### Conventions

- Use `STRICT` mode for SQLite tables (enforces type checking)
- Use `CHECK` constraints for database-level invariants
- Nullable column pairs (min/max) should have CHECK constraints ensuring both-or-neither
- Always include `-- +goose Down` for rollback
- Use `-- +goose StatementBegin/End` for multi-statement blocks

### Running Migrations

```bash
goose -dir db/migrations sqlite3 path/to/db up       # apply all
goose -dir db/migrations sqlite3 path/to/db status    # check status
goose -dir db/migrations sqlite3 path/to/db down      # rollback last
```

---

## Repository Implementation

Repositories live in `internal/storage/` and implement domain interfaces by wrapping sqlc's `*Queries`.

### Constructor

```go
type BoardgameRepository struct {
    queries *db.Queries
}

func NewBoardgameRepository(queries *db.Queries) *BoardgameRepository {
    return &BoardgameRepository{queries: queries}
}
```

### Method Pattern

Every method follows: call sqlc → translate result → return domain type.

Always wrap errors with operation context. Return `nil` for slices on error, zero-value structs for single entities on error.

```go
func (r *BoardgameRepository) GetByID(ctx context.Context, id int64) (domain.Boardgame, error) {
    result, err := r.queries.GetBoardgameByID(ctx, id)
    if err != nil {
        return domain.Boardgame{}, fmt.Errorf("getting boardgame %d: %w", id, err)
    }
    return gameFromResult(result), nil
}

func (r *BoardgameRepository) Create(ctx context.Context, game domain.Boardgame) (domain.Boardgame, error) {
    result, err := r.queries.CreateBoardgame(ctx, toCreateParams(game))
    if err != nil {
        return domain.Boardgame{}, fmt.Errorf("creating boardgame: %w", err)
    }
    return gameFromResult(result), nil
}

func (r *BoardgameRepository) List(ctx context.Context) ([]domain.Boardgame, error) {
    results, err := r.queries.ListBoardgames(ctx)
    if err != nil {
        return nil, fmt.Errorf("listing boardgames: %w", err)
    }
    games := make([]domain.Boardgame, len(results))
    for i, r := range results {
        games[i] = gameFromResult(r)
    }
    return games, nil
}
```

---

## Type Translation

The storage layer is the **only place** that knows about `sql.NullXxx` types. Helper functions handle conversion.

### Database → Domain

```go
func gameFromResult(r db.Boardgame) domain.Boardgame {
    return domain.Boardgame{
        ID:         r.ID,
        Name:       r.Name,
        Complexity: fromNullInt64[uint8](r.Complexity),
        Players:    fromNullRange(r.MinPlayers, r.MaxPlayers),
    }
}

func fromNullInt64[T ~int64 | ~uint8](n sql.NullInt64) domain.Optional[T] {
    if n.Valid {
        return domain.Some(T(n.Int64))
    }
    return domain.None[T]()
}

func fromNullString(n sql.NullString) domain.Optional[string] {
    if n.Valid {
        return domain.Some(n.String)
    }
    return domain.None[string]()
}

func fromNullRange(min, max sql.NullInt64) domain.Optional[domain.Range] {
    if min.Valid && max.Valid {
        r, err := domain.Between(uint16(min.Int64), uint16(max.Int64))
        if err == nil {
            return domain.Some(r)
        }
    }
    return domain.None[domain.Range]()
}
```

### Domain → Database

```go
func toCreateParams(g domain.Boardgame) db.CreateBoardgameParams {
    params := db.CreateBoardgameParams{
        Name: g.Name,
        Complexity: toNullInt64(g.Complexity),
    }

    if g.Players.IsSet() {
        params.MinPlayers = sql.NullInt64{Valid: true, Int64: int64(g.Players.Value().Min())}
        params.MaxPlayers = sql.NullInt64{Valid: true, Int64: int64(g.Players.Value().Max())}
    }

    return params
}

func toNullInt64[T ~int64 | ~uint8](o domain.Optional[T]) sql.NullInt64 {
    if o.IsSet() {
        return sql.NullInt64{Valid: true, Int64: int64(o.Value())}
    }
    return sql.NullInt64{}
}
```

### Complex Type Serialization

For types that don't map to a single column (e.g., `[]string`), use simple serialization:

```go
// Store []string as CSV
params.Players = strings.Join(session.Players, ",")

// Retrieve CSV as []string
session.Players = strings.Split(result.Players, ",")

// Store time.Time as RFC3339 string
params.PlayedAt = session.PlayedAt.Format(time.RFC3339)

// Retrieve RFC3339 string as time.Time
playedAt, err := time.Parse(time.RFC3339, result.PlayedAt)
```

---

## SQL Conventions

### Table Design

- `INTEGER PRIMARY KEY` for auto-incrementing IDs (SQLite alias for rowid)
- `TEXT NOT NULL DEFAULT ''` for required strings with sensible defaults
- Nullable columns for truly optional data
- `STRICT` mode on all tables
- `CHECK` constraints for invariants the database should enforce

### Query Naming

Follow the pattern `<Verb><Entity>`:

| Pattern | Example |
|---------|---------|
| `Get<Entity>ByID` | `GetBoardgameByID` |
| `List<Entity>s` | `ListBoardgames` |
| `Create<Entity>` | `CreateBoardgame` |
| `Update<Entity>` | `UpdateBoardgame` |
| `Delete<Entity>` | `DeleteBoardgame` |
| `Search<Entity>s` | `SearchBoardgames` |
| `List<Entity><Related>` | `ListGameSessions` |

### Workflow

1. Update schema → create goose migration
2. Write queries → add to `db/queries/<entity>.sql`
3. Generate → `sqlc generate`
4. Implement → update repository in `internal/storage/`
5. Verify → run `go build ./...` to catch type mismatches
